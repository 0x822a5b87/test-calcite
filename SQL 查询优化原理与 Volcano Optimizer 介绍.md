### SQL 查询优化原理与 Volcano Optimizer 介绍

基于规则的优化方法的要点在于**结构匹配和替换**。 应用规则的算法一般需要先在关系代数结构上匹配一部分局部的结构， 再根据结构的特点进行变换乃至替换操作。

![pattern-match-rule](../images/003/pattern-match-rule.png)

#### Volcano Optimizer

##### 成本最优假设

![cumulative-cost-assumption](../images/003/cumulative-cost-assumption.png)

成本最优假设利用了贪心算法的思想，在计算的过程中， 如果一个方案是由几个局部区域组合而成，那么在计算总成本时， 我们只考虑每个局部目前已知的最优方案和成本即可。

对于成本最优假设的另一种更直观的描述是，如果关系代数局部的某个输入的计算成本上升， 那么这一子树的整体成本趋向于上升，反之则会下降。也即是在上图右侧有

> Cost(A)∼Cost(B)+Cost(C)

##### 动态规划算法与等价集合

由于引入了成本最优假设，在优化过程中我们就可以对任意子树目前已知的最优方案和最优成本进行缓存。 此后在计算的过程中，如果需要利用这一子树，可以直接使用之前缓存的结果。这里应用了动态规划算法的思想。

要实现这一算法，只需要建立缓存结果到子树双向映射即可。在 Calcite 的实现当中，一颗子树使用其根结点作为代表。 某一棵子树所有可能的变换方案组成的集合被称为等价集合(Equivalent Set)， 等价集合将会维护自身元素当中具有最优成本的方案。

![equivalent-set](/Users/0x822a5b87/code/hangyudu/0x822a5b87.github.io/source/images/003/equivalent-set.png)

> 等价集合在 Calcite 当中对应的是`RelSet`类。

##### 如何优化等价集合的收集和存储

> 对每一颗子树都枚举其等价集合的内容会十分耗费空间。其实，对于某一棵以 A 为根结点的子树来说， 我们只关心 A 本身和包含 A 了的匹配内的节点。对于 A 和包含 A 的匹配之外的部分， 我们可以直接链接到子树对应的等价集合当中。基于成本最优假设，在计算方案成本的时候， 我们还可以直接从这些部分的等价集合中选取最佳方案。

这里，按照我的理解就是，每个节点都只需要关注：

1. 自身
2. 自身的临近节点（父节点或者子节点）

如果知道了包含以上两个部分的节点的**等价集合**，我们就可以使用**自顶向下**和**自底向上**的方式